"""
主要使用引用计数来回收垃圾，在引用计数基础上使用标记清除来解决循环引用问题，使用分代回收机制
以空间换取时间来提高回收效率

标记清除到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放

分代回收
将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量
Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，
老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内
"""
# 引用计数
a = 1  # ref = 1
b = a  # ref = 2
b = None  # ref = 1
del a # ref = 0 回收掉

# 循环引用
a = [1]
b = [2]
a.append(b)
b.append(a)
del a
del b
"""
[1] ref= 1+1 -1 =1
[2] ref = 1+1 -1 =1
"""